import SEO from "../../components/seo.js";
import Layout from "../../components/layout.js";
import JSLayout from "../../components/masters/javascript-layout.js";
import image from "../../images/well-known-symbols.png";


<Layout>
<SEO title="Types in JavaScript" />
<JSLayout>

# Types in JavaScript

As per [ECMAScript specification](https://www.ecma-international.org/ecma-262/#sec-ecmascript-language-types), there are 7 types. They are:

1. Undefined
2. Null
3. Boolean
4. String
5. Symbol
6. Number
7. Object

Any value in JavaScript falls under any one of the above listed types.

## Undefined

Undefined is a primitive type in JavaScript. There is only one value in JavaScript that is of this type. And that value is `undefined`.

## Boolean

Boolean represents a logical entity. Logical entities are used to write conditions and enable branching in the program. There are only 2 values in JavaScript that are of Boolean type. They are `true` and `false`.

```javascript
// Branching
if (true) {
  console.log("I am truthy");
} else {
  console.log("I will never be logged");
}
```

### Falsy values

When we use any data types as a logical entity, JavaScript automatically converts that value to a boolean `true` or `false`. For example, in the following snippet we use `"hello"` as a logical entity.

```javascript
if ("hello") {
  console.log("hello is true");
} else {
  console.log("hello is false");
}
```

Here the output is `"hello is true"`. It is because, JavaScript automatically converts a non-empty string to a `true`. There are some values, when converted to boolean, results in `false`. Those values are called _falsy values_. They are:

- `0`
- `-0`
- `null`
- `false` Obviously
- `NaN`
- `undefined`
- `""` Empty string

All other values in JavaScript are truthy values.

> An empty object `{}` and empty array `[]` are truthy values. It is not falsy like an empty string.

> The string "false" is a non-empty string. So when it is converted to boolean, it is a truthy value.

### Converting any value to boolean

We can convert any value in JavaScript to boolean type. This can be done using 2 techniques.

#### `Boolean` function

We can use `Boolean` function to convert any values to boolean type.

```javascript
console.log(Boolean("A string")); // true
console.log(Boolean(""));         // false
console.log(Boolean(0));          // false
console.log(Boolean({}));         // true
```

#### `!!` Double negation

In JavaScript `!` can be used as a NOT operator. In Mathematics, if we have a number `23`, negating it results in `-23`. Again negating it reverts it back to `23`. In similar way, in JavaScript when using `!`, it negates the value and the output is a boolean value.

Here is an example. We know that, a non-empty string is a truthy value. Let us do a single negation first.

```javascript
console.log(!"hello"); // false
```

We use this behaviour of `!` to convert a value to boolean type by negating again.

```javascript
console.log(!!"hello"); // true
```

## String

In JavaScript, _String_ is a primitive data type. It is used in JavaScript to work with texts.

Here is an example of a string.

```javascript
"backbencher!"
```

Each character in a string occupy __16 bits__. Number of 16-bit values in a string forms the length of the string. The length of above string is 12.

### Unicode Support

Each character in a string occupies 16 bits to consider Unicode characters. Since JavaScript supports unicode characters, we can use unicodes in our texts. Here we are going to assign a malayalam language word to a variable.

```javascript
const fruit = "ആപ്പിൾ";
console.log(fruit); // "ആപ്പിൾ"
```

## Symbol

**Symbol** is a new primitive data type introduced in ES6.

### Creating symbol variable

A variable of _Symbol_ type is created using `Symbol()` function.

```javascript
const s1 = Symbol();
console.log(typeof s1); // "symbol"
```

While creating a symbol variable, we can optionally pass a description.

```javascript
const id = Symbol("UserId");
const name = Symbol("UserName");
```

`"UserId"` and `"UserName"` are the descriptions. Descriptions help in debugging. Other than that, there is no impact for description strings.

### Symbols are unique

Every symbol value returned from `Symbol()` is anonymous and unique. We can consider `Symbol()` function as a magic box which throws out a unique toy each time when we open it.

Let us create 2 symbols.

```javascript
const symbol1 = Symbol();
const symbol2 = Symbol();
```

Here, we open the magic box 2 times. Now let us see what toy we have received by printing the symbol variables.

```javascript
console.log(symbol1); // Symbol()
console.log(symbol2); // Symbol()
```

Both statements print `Symbol()` in console. Did you expect a random string? If yes, that is not happening. So, is there any way to see the contents of both variables? No. That is why they say `Symbol()` produces anonymous and unique values.

In that case, how can we make sure that both the variables are unique? That is a guarantee by JavaScript. Now for our relief, at least we can try comparing them.

```javascript
console.log(symbol1 == symbol2); // false
```

Seeing a `false` is assuring. It means `symbol1` and `symbol2` are unique.

Having same description, does not create identical symbols. Descriptions are purely for debugging purpose. It does not have any impact on uniquness of generated symbols.

```javascript
const s1 = Symbol("Disney");
const s2 = Symbol("Disney");
console.log(s1 == s2); // false
```

`s1` is not equal to `s2`, even though their Symbol description is same.

### Symbols as object keys

In JavaScript, an object key should be either a string or a symbol. Other data types are not supported as object keys. Here is an example of an object literal.

```javascript
const obj = {
  name: "John Doe",
  age: 23
};
```

Now let us add a new Symbol key to `obj`.

```javascript
obj[Symbol("id")] = 1234;
```

> We need to use square bracket`[]` syntax to add a Symbol key property to an object. Dot(`.`) notation is not allowed to add Symbols to objects. Following code is invalid.
>
> ```javascript
> obj.Symbol("id") = 1234;
> ```

What is the use of having a Symbol key?

#### Symbol keys in `for..in`

`obj` object which we created above now have 3 keys(2 strings and 1 symbol). Now let us log the key names using `for..in` loop.

```javascript
for (key in obj) {
  console.log(key);
}
```

And the output is

```console
"name"
"age"
```

We cannot see `Symbol("id")` in the list. Symbol keys act like private properties(in reality, they are not). They are not looped through when used with `for..in` loop.

So, is this hiding behaviour applicable for all loops on objects?

#### Symbol keys with `Object.keys()`

The `Object.keys()` method returns an **array** of a given object's own enumerable property names, in the same order as we get with a normal loop.

Let us try `Object.keys()` on `obj` object. Here is the full code from object creation to printing property names.

```javascript
const obj = {
  name: "John Doe",
  age: 23
};
obj[Symbol("id")] = 1234;

console.log(Object.keys(obj)); // ["name", "age"]
```

Here also the symbol keys are omitted. Only the string property names `name` and `age` are printed.

### Symbols do not auto-convert to a string

In JavaScript, we can explicitly convert one data type to another using various techniques. One common conversion is converting a data type to string. All data types have `.toString()` method which makes this job easy. Here are few examples.

```javascript
console.log(true.toString()); // "true"
console.log(Number(123).toString()); // "123"
console.log([3, 5, 8].toString()); // "3,5,8"
```

In similar manner, we can convert a symbol to a string using `.toString()` method.

```javascript
const symbol1 = Symbol("Token");
console.log(symbol1.toString()); //"Symbol(Token)";
```

A symbol when converted to a string, outputs the `Symbol()` function which created it, along with the symbol description(`Token`).

There are cases where JavaScript implicitly convert a data type to string. Here are two examples.

```javascript
console.log(1 + "2"); // "12"
alert([3, 4, 5]); // alerts "3,4,5"
```

What if we try to alert the value of a symbol? It throws an error. Let us try.

```javascript
const symbol1 = Symbol("Token");
alert(symbol1); // TypeError: Cannot convert a Symbol value to a string
```

This says that, if we want to convert a symbol to string, we need to explicitly use `.toString()` method. Otherwise, implicit conversion to string value results in _TypeError_.

### Well-Known symbols

So far we learned how to create custom symbols. There are a set of built-in symbols in JavaScript called as Well-Known symbols. We can find these symbols as constants of `Symbol` class. There are 13 such symbols.

1. `Symbol.asyncIterator`
2. `Symbol.hasInstance`
3. `Symbol.isConcatSpreadable`
4. `Symbol.iterator`
5. `Symbol.match`
6. `Symbol.matchAll`
7. `Symbol.replace`
8. `Symbol.search`
9. `Symbol.species`
10. `Symbol.split`
11. `Symbol.toPrimitive`
12. `Symbol.toStringTag`
13. `Symbol.unscopables`

We can find all these constant symbols, by going to browser console and type `Symbol.`. Browser will show above symbols in the auto complete.

<img src={image} alt="Well known symbols" />

Well-known symbols are used by various algorithms(like `for..of` loop) within JavaScript specification. To understand it better, let us take `Symbol.iterator`. This symbol will be present as a key in any iterable object. Let us verify it.

An array in JavaScript is an iterable object. Whereas an object literal is not iterable.

```javascript
// Iterable object
const arr = [2, 4, 6];

// Non iterable
const obj = {
  name: "John",
  age: 20
};
```

Now let us see the value present in the `Symbol.iterator` key.

```javascript
console.log(arr[Symbol.iterator]); // function values() { [native code] }

console.log(obj[Symbol.iterator]); // undefined
```

Above statements show that, there is a `Symbol.iterator` key in an array, but not present in an object. We can therefore test if an object is an iterable object by checking for `Symbol.iterator` key.

Now let us go little more in depth. We now know, the `Symbol.iterator` key inside `arr` contains a function. If we execute that function, it returns an _iterator_ object. Just for users who are new to iterators, an iterator object contains a `next()` method which returns values one by one upon each invocation. Let us try it.

```javascript
const arrayIteratorObject = arr[Symbol.iterator]();

console.log(arrayIteratorObject.next().value); // 2
console.log(arrayIteratorObject.next().value); // 4
console.log(arrayIteratorObject.next().value); // 6
console.log(arrayIteratorObject.next().value); // undefined
```

## Number

In most of the programming languages, integer values and floating-point(numbers with decimal) values are treated differently. The amount of memory used for both types also varies. But in JavaScript, there is __no distinction__ between integer values and floating-point values.

### Memory and Range

In JavaScript, both integer and floating-point values are treated in the same way. Therefore, considering the worst case, the memory allocation for a number type should consider floating-point values. Each number in JavaScript occupies __64 bit__ of memory. The numbers are stored in _Double-precision floating-point_ format as per [IEEE 754](https://en.wikipedia.org/wiki/Double-precision_floating-point_format) standard.

In case of integers, JavaScript can accurately represent all integers between -9007199254740992(-2<sup>53</sup>) and 9007199254740992(2<sup>53</sup>), inclusive. Beyond this range, the precision might lose. Let us try adding one to the maximum range.

```javascript
console.log(9007199254740992+1); // 9007199254740992
```

The expected output is 9007199254740993. But the actual output is 9007199254740992.



## Type of Variables

Here is a variable declaration in JavaScript:

```javascript
var a;
```

What is the type of variable `a`?

In JavaScript, the variables declared do not have a type associated with it. Only the values in JavaScript have a type associated with it.

So in the above case, when a variable is declared, a value of `undefined` is assigned to it automatically by JavaScript. Therefore the type of `a` is _undefined_ for now.

```javascript
typeof a; // "undefined"
```

If later, another value is assigned to `a`, its type might change.



</JSLayout>
</Layout>
