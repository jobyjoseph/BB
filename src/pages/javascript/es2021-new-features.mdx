import SEO from "../../components/seo.js";
import Layout from "../../components/layout.js";
import JSLayout from "../../components/masters/javascript-layout.js";
import Image from "../../components/utils/image/image.js";
import imageChromeGarbageCollector from "../../images/articles/2020/chrome-garbage-collection.png";

<Layout>
<SEO title="ES2021 / ES12 New Features" />
<JSLayout>

# ES2021 / ES12 New Features

ECMAScript 2021 version is expected to be released in the month of June 2021. Here are some of the features we can expect in ES2021 or ES12. The list prepared based on ECMAScript proposal status and the new features released by Google Chrome V8 engine.

All the features listed below, at the time of writing is supported in Google Chrome Canary build.

## String replaceAll() Method

`String.prototype.replaceAll()` replaces all occurrence of a string with another string value.

Currently JavaScript string has a `replace()` method. It can be used to replace a string with another string.

```javascript
const str = "Backbencher sits at the Back";
const newStr = str.replace("Back", "Front");
console.log(newStr); // "Frontbencher sits at the Back"
```

If the input pattern is a string, `replace()` method only replaces the first occurrence. That is why in the code, the second occurrence of `"Back"` is not replaced.

We can do a **full replacement** only if we supply the pattern as a **regular expression**.

```javascript
const str = "Backbencher sits at the Back";
const newStr = str.replace(/Back/g, "Front"); // highlight-line
console.log(newStr); // "Frontbencher sits at the Front"
```

`String.prototype.replaceAll()` is trying to bring the full replacement option even when the input pattern is a **string**.

## Private Methods

Private methods can be accessible only inside the class where it is defined. Private method names starts with `#`.

```javascript
class Person {

  // Private method
  #setType() {
    console.log("I am Private");
  }

  // Public method
  show() {
    this.#setType();
  }

}

const personObj = new Person();
personObj.show(); // "I am Private";
personObj.setType(); // TypeError: personObj.setType is not a function
```

Since `setType()` is a private method, `personObj.setType` returns `undefined`. Trying to use `undefined` as a function throws TypeError.

## Private Accessors

Accessor functions can be made private by prepending `#` to the function name.

```javascript
class Person {
  // Public accessor
  get name() { return "Backbencher" }
  set name(value) {}

  // Private accessor
  get #age() { return 42 }
  set #age(value) {}
}
```

In the above code `get` and `set` keywords make `name` an accessor property. Even though `name` looks like a function, it can be read like a normal property.

```javascript
const obj = new Person();
console.log(obj.name); // "Backbencher"
console.log(obj.age); // undefined
```

## WeakRef and Finalizers

`WeakRef` stands for Weak References. Main use of weak references is to implement **caches or mappings to large objects**. In such scenarios, we do not want to keep a lot of memory for a long time saving this rarely used cache or mappings. We can allow the memory to be garbage collected soon and later if we need it again, we can generate a fresh cache.

JavaScript is a garbage collected language. If a variable is no longer reachable, JavaScript garbage collector automatically removes it. You can read more on JavaScript garbage collection here in [MDN site](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management).

Consider the following code:

```javascript
const callback = () => {
  const aBigObj = {
    name: "Backbencher"
  };
  console.log(aBigObj);
}

(async function(){
  await new Promise((resolve) => {
    setTimeout(() => {
      callback();
      resolve();
    }, 2000);
  });
})();
```

The code might look complicated. But basically, what we do is create a function named `callback()` and execute it using `setTimeout()`. The `async` wrapping is just to use `await` functionality. `await` is a feature in ES6, that helps to execute asynchronous code in synchronous way.

When executing above code, it prints `"Backbencher"` after 2 seconds. Based on how we use the `callback()` function, `aBigObj` is stored in memory forever, may be.

Let us make `aBigObj` a weak reference.

```javascript
const callback = () => {
  // highlight-start
  const aBigObj = new WeakRef({
    name: "Backbencher"
  });

  console.log(aBigObj.deref().name);
  // highlight-end
}

(async function(){
  await new Promise((resolve) => {
    setTimeout(() => {
      callback(); // Guaranteed to print "Backbencher"
      resolve();
    }, 2000);
  });

  await new Promise((resolve) => {
    setTimeout(() => {
      callback(); // No Gaurantee that "Backbencher" is printed
      resolve();
    }, 5000);
  });
})();
```

A WeakRef is created using `new WeakRef()`. Later the reference is read using `.deref()` method. Inside the `async` function, The first `setTimeout()` will surely print the value of `name`. That is guaranteed in the first turn of event loop after creating the weak reference.

But there is no guarantee that the second `setTimeout()` prints `"Backbencher"`. It might have been sweeped by the gargage collector. Since the garbage collection works differently in different browsers, we cannot guarantee the output. That is also why, we use WeakRef in situations like managing cache.

### Finalizers

`FinalizationRegistry` is a companion feature of `WeakRef`. It lets programmers register callbacks to be invoked after an object is garbage collected.

```javascript
const registry = new FinalizationRegistry((value) => {
  console.log(value);
});
```

Here `registry` is an instance of `FinalizationRegistry`. The callback function passed to `FinalizationRegistry` gets triggered when an object is garbage collected.

```javascript{numberLines: true}
(function () {
  const obj = {};
  registry.register(obj, "Backbencher");
})();
```

Line 3 attaches `obj` to `registry`. When `obj` is garbage collected, the second argument of `.register()` method is passed to the callback function. So, according to our code logic, when `obj` is garbage collected, `"Backbencher"` is passed to the callback function and is printed in the console.

When I executed above code in Google Chrome Canary console, after about 1 min, it printed `"Backbencher"` in the console. Another way to force garbage collection in chrome is to click on _Collect Garbage_ icon. We can find it in _Performance_ tab.

<Image src={imageChromeGarbageCollector} style={{maxWidth: "500px", display: "block", margin: "auto"}} alt="Chrome Garbage Collection" />

</JSLayout>
</Layout>
